interface BinaryOperator {
    readonly type: 'binary';
    readonly priority: number;
    readonly mathCode: string;
    readonly plainText: string;
    readonly LaTeX: string;
    readonly ptOp1: number;
    readonly ptOp2: number;
    readonly ptOut: number;
    readonly texOp1: number;
    readonly texOp2: number;
    readonly texOut: number;
}

export const BINARY_OPERATORS: {readonly [key: string]: BinaryOperator} = {
    or: {
        type: 'binary',
        priority: 0,
        mathCode: 'BA',
        plainText: 'or',
        LaTeX: '&0 \\text{ or } &1',
        ptOut: 0,
        texOut: 0,
        ptOp1: 0,
        ptOp2: 0,
        texOp1: 0,
        texOp2: 0,
    },
    and: {
        type: 'binary',
        priority: 1,
        mathCode: 'BB',
        plainText: 'and',
        LaTeX: '&0 \\text{ and } &1',
        ptOut: 1,
        texOut: 1,
        ptOp1: 1,
        ptOp2: 1,
        texOp1: 1,
        texOp2: 1,
    },
    '+': {
        type: 'binary',
        priority: 4,
        mathCode: 'CB',
        plainText: '+',
        LaTeX: '&0 + &1',
        ptOut: 4,
        texOut: 4,
        ptOp1: 4,
        ptOp2: 4,
        texOp1: 4,
        texOp2: 4,
    },
    '-': {
        type: 'binary',
        priority: 4,
        mathCode: 'CC',
        plainText: '-',
        LaTeX: '&0 - &1',
        ptOut: 4,
        texOut: 4,
        ptOp1: 4,
        ptOp2: 5,
        texOp1: 4,
        texOp2: 5,
    },
    '*': {
        type: 'binary',
        priority: 5,
        mathCode: 'CD',
        plainText: '*',
        LaTeX: '&0 * &1',
        ptOut: 5,
        texOut: 5,
        ptOp1: 5,
        ptOp2: 5,
        texOp1: 5,
        texOp2: 5,
    },
    '/': {
        type: 'binary',
        priority: 5,
        mathCode: 'CE',
        plainText: '/',
        LaTeX: '\\frac{ &0 }{ &1 }',
        ptOut: 5,
        texOut: 6,
        ptOp1: 5,
        ptOp2: 6,
        texOp1: 0,
        texOp2: 0,
    },
    '%': {
        type: 'binary',
        priority: 5,
        mathCode: 'CF',
        plainText: 'mod',
        LaTeX: '&0 \\text{ mod } &1',
        ptOut: 5,
        texOut: 5,
        ptOp1: 5,
        ptOp2: 6,
        texOp1: 5,
        texOp2: 6,
    },
    '^': {
        type: 'binary',
        priority: 6,
        mathCode: 'CG',
        plainText: '^',
        LaTeX: '&0 ^{ &1 }',
        ptOut: 6,
        texOut: 6,
        ptOp1: 8,
        ptOp2: 6,
        texOp1: 8,
        texOp2: 0,
    },
    '=': {
        type: 'binary',
        priority: 3,
        mathCode: 'CN',
        plainText: '=',
        LaTeX: '&0 = &1',
        ptOut: 3,
        texOut: 3,
        ptOp1: 4,
        ptOp2: 4,
        texOp1: 4,
        texOp2: 4,
    },
    '!=': {
        type: 'binary',
        priority: 3,
        mathCode: 'CO',
        plainText: '≠',
        LaTeX: '&0 \\neq &1',
        ptOut: 3,
        texOut: 3,
        ptOp1: 4,
        ptOp2: 4,
        texOp1: 4,
        texOp2: 4,
    },
    '>=': {
        type: 'binary',
        priority: 3,
        mathCode: 'CP',
        plainText: '≥',
        LaTeX: '&0 \\ge &1',
        ptOut: 3,
        texOut: 3,
        ptOp1: 4,
        ptOp2: 4,
        texOp1: 4,
        texOp2: 4,
    },
    '<=': {
        type: 'binary',
        priority: 3,
        mathCode: 'CQ',
        plainText: '≤',
        LaTeX: '&0 \\le &1',
        ptOut: 3,
        texOut: 3,
        ptOp1: 4,
        ptOp2: 4,
        texOp1: 4,
        texOp2: 4,
    },
    '>': {
        type: 'binary',
        priority: 3,
        mathCode: 'CR',
        plainText: '>',
        LaTeX: '&0 > &1',
        ptOut: 3,
        texOut: 3,
        ptOp1: 4,
        ptOp2: 4,
        texOp1: 4,
        texOp2: 4,
    },
    '<': {
        type: 'binary',
        priority: 3,
        mathCode: 'CS',
        plainText: '<',
        LaTeX: '&0 < &1',
        ptOut: 3,
        texOut: 3,
        ptOp1: 4,
        ptOp2: 4,
        texOp1: 4,
        texOp2: 4,
    },
    dot: {
        type: 'binary',
        priority: 5,
        mathCode: 'EB',
        plainText: '•',
        LaTeX: '&0 \\cdot &1',
        ptOut: 5,
        texOut: 5,
        ptOp1: 6,
        ptOp2: 6,
        texOp1: 6,
        texOp2: 6,
    },
    cross: {
        type: 'binary',
        priority: 5,
        mathCode: 'EC',
        plainText: '⨯',
        LaTeX: '&0 \\times &1',
        ptOut: 5,
        texOut: 5,
        ptOp1: 6,
        ptOp2: 6,
        texOp1: 6,
        texOp2: 6,
    },
    scalar_of: {
        type: 'binary',
        priority: 3,
        mathCode: 'FA',
        plainText: ' scalar of ',
        LaTeX: '&0 \\text{ scalar of } &1',
        ptOut: 3,
        texOut: 3,
        ptOp1: 5,
        ptOp2: 4,
        texOp1: 5,
        texOp2: 4,
    },
    '~': {
        type: 'binary',
        priority: 3,
        mathCode: 'FB',
        plainText: '~',
        LaTeX: '&0 \\sim &1',
        ptOut: 3,
        texOut: 3,
        ptOp1: 4,
        ptOp2: 4,
        texOp1: 4,
        texOp2: 4,
    },
    contains: {
        type: 'binary',
        priority: 3,
        mathCode: 'GA',
        plainText: 'contains',
        LaTeX: '&0 \\text{ contains } &1',
        ptOut: 3,
        texOut: 3,
        ptOp1: 4,
        ptOp2: 4,
        texOp1: 4,
        texOp2: 4,
    },
    in_span: {
        type: 'binary',
        priority: 3,
        mathCode: 'GB',
        plainText: 'in span',
        LaTeX: '&0 \\text{ in span } &1',
        ptOut: 3,
        texOut: 3,
        ptOp1: 4,
        ptOp2: 0,
        texOp1: 4,
        texOp2: 0,
    },
    exactly_equal: {
        type: 'binary',
        priority: 3,
        mathCode: 'GE',
        plainText: 'identical to',
        LaTeX: '&0 \\text{ identical to } &1',
        ptOut: 3,
        texOut: 3,
        ptOp1: 4,
        ptOp2: 4,
        texOp1: 4,
        texOp2: 4,
    },
};

function remap(): {readonly [key: string]: string} {
    const remappedBinaryOperators: {[key: string]: string} = {};
    for (let c in BINARY_OPERATORS) {
        if (BINARY_OPERATORS.hasOwnProperty(c)) {
            remappedBinaryOperators[BINARY_OPERATORS[c].mathCode] = c;
        }
    }
    return remappedBinaryOperators;
}

export const REMAPPED_BINARY_OPERATORS = remap();
